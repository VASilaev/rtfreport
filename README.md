# Установка
Для установки в проект импортируйте файл `Report.bas`. Запустите процедуру `InstallRepSystem`, что бы создать таблицу для хранения шаблонов. Запустите процедуру `InstallReportTemplate`, что бы добавить шаблон в хранилище;

Подготовленные шаблоны хранятся в таблице `t_rep`. Большинство полей заполняются процедурой `InstallReportTemplate`.



Наименование столбца|Описание
|---|---|
sCaption|Название отчета. Может применяться в качестве параметра vReport функции PrintReport.
sDescription|Более подробное описание отчета (опиши зачем отчет нужен)
sOrignTemplate|Путь до шаблона. При первом построении отчета шаблон переведется во внутреннюю форму и сохранится в `clTemplate`. В дальнейшем он будет обновляться если дата изменения файла будет больше чем в поле `dEditTemplate`. После сохранения шаблона внешний файл больше не нужен
clTemplate|Скомпилированный шаблон RTF

Так же возможно построение отчета напрямую из файла шаблона, без сохранения в `t_rep`. Для этого при вызове функции `PrintReport` в параметре `vReport` необходимо передать не код шаблона в таблице `t_rep`, а путь до файла шаблона. Данные метод не много медленнее, так как приходится каждый раз разбирать файл на части.
Отчет готовится в текстовом процессоре MS Word, с включением управляющих инструкций-полей (добавляются сочетанием клавиш `Ctrl + F9`) и имеют формат `<Команда>(<Аргумент>)`. Некоторые управляющие конструкции такие как `IF`, `SCAN` - парные и требуют соответствующих закрывающих команд.

# Инструкции.

1. `{Scan(Имя_курсора for Текст_запроса)} {EndScan()}`– Открывает новый набор данных и подготавливает его. Если набор будет пуст, то управление передается на позицию идущую за парной инструкцией `EndScan()`. `Имя_курсора` и `Текст_запроса` должны быть выражением или текстовым литералом заключенном в двойные кавычки. 

    Имя курсора будет использовано как префикс к результатам полученным в ходе выборки.

    **Пример:** 
    ```
    {scan("a" for "select 1 as b from dual"} {f(a.b)} {endScan()}
    ```
    Открывает курсор с именем `а`, считывает результаты запроса и укладывает результат в переменную с именем `a.b`

    Дополнительно создаются переменные `Имя_Курсора.EOF` возвращающие `True` на последней строке запроса и `Имя_Курсора.rownum` содержащей номер текущей строки. После `endScan()` значения переменных не очищается и их можно использовать. Явного запрета на переиспользование имени курсора во вложенном цикле - нет, но вложенный цикл может затереть данные родительского цикла.

    В тексте запроса можно обращаться к переменным окружения, для этого вставьте переменную обрамив ее символами %.

    **Пример:**
    ```
    {scan("a" for "select * from MyTable where id = %id%"}
    ```
    или пример с вложенными запросами 
    ```
    {scan("Parent" for "select * from MyTable where id = %id%"}{scan("Child" for "select * from MyChildTable where idParent = %Parent.id%"}{endScan()}{endScan()}
    ```

    для некоторых типов возможно указать формат: `%Имя_переменной; Формат%`

    для создания критерия отбора необходимо использовать следующую подстановку `%Имя_поля_Фильтра; stdf:Имя_поля%` что означает примени параметр `Имя_поля_Фильтра` к полу `Имя_поля`. Для добавления параметра в окружение можно использовать функцию `BuildParam` совместно с `GetFilter`. См. примеры вызова ниже.

2. `{If(<Выражение>)}… {elif (<Выражение>)}…{else()}…{endif()}` обычный оператор условия.

3. `{skip()} {endskip([skip_lf])}` Вырезают из шаблона часть, если у `endskip` указан параметр `skip_lf`, то он заберет с собой перевод строки

4. `{f(<Выражение>)}` Выводит выражение в отчете

# Выражения


Для упрощения парсера в выражениях используются только функции. Все операции так же заменены на функции. Например если нужно вычислить выражение 2+3 то необходимо записать это следующим образом: `plus(2;3)`. Параметры функций отделяются друг от друга символом `;`.

### Список встроенных функций

Функция|Синоним|Кол-во операндов|Результат|Описание
|---|---|---|---|---|
plus|+|2..16|Double|Складывает все операнды
minus|-|2|Double|Вычитание
mul|*|2..16|Double|Умножение
div|/|2|Double|Деление
Idiv|\\|2|Long|Целочисленное деление
mod||2|Long|Остаток от деления
concat||2..16|String|Объединяет все операнды в одну строку
eq|=|2|Boolean|Проверка на равенство 
ls|<|2|Boolean|Истина если первое меньше второго
gr|>|2|Boolean|Истина если первое больше второго
le|<=|2|Boolean|Истина если первое не больше второго
ge|>=|2|Boolean|Истина если первое не меньше второго
ne|<> или !=|2|Boolean|Истина если первое не равно второму
or||2..16|Boolean|Истина если хотя бы один истинный
and||2..16|Boolean|Истина если все истинны
xor||2..16|Boolean|Сумма по модулю 2 всех параметров
not||1|Boolean|Истина если параметр ложь
isnull||1|Boolean|Истина если значение Null 
rel||1||Вычисляет строковое значение и возвращает значение переменной с таким именем
iif||3||Если выражение1 истинно то возвращает выражение2 в противном случае Выражение3
calc||2||Вычисляет оба параметра и присваивает переменной с именем первого параметра значение второго параметра, и возвращается имя переменной
open||имя_файла\[;кодировка\]|Byte()  или Строка|Открывает указанный файл. Если кодировка не указана, то файл открывается как бинарный и результат можно использовать для вставки изображения по имени файла. Если имя файла начинается с ".\", то в начало подставляется имя папки в которой размещена БД. Кодировки: utf-8, windows-1251
rtfimg||бинарный_файл; ширина; высота|Rtf блок|Функция возвращает rtf блок, данные передаются как сырые данные файла byte(). Данные можно получить из поля OLE с бинарными данными или функцией open. Вторым и третьим параметром передается соответственно ширина и высота рисунка в миллиметрах
attach||Имя_поля; Маска||Извлекает файл из поля с типом Attachment Функция имеет второй параметр где указывается маска файла в формате RegExp. По умолчанию используется маска ".+\.(jpg|jpeg|png|emf)$". Если маске соответствует несколько файлов выбирается первый. На данный момент эта единственная функция которая может работать с полями типа Attachments.

Если Функция не будет найдена в предопределенном наборе, будет попытка вызвать пользовательскую.

Пользовательская функция имеет следующий интерфейс


```vb
Public function MyFnс(pParamList, aArg)
 'pParamList – Словарь с окружением, содержит все переменные и объекты текущего шаблона. Вызови pParamList("a.b") что бы получить значение поля b курсора a
 'aArg – массив с аргументами. за раз можно передать не более 16 параметров
End function
```

# Пример запуска отчета

Все переменные хранятся в объекте типа Dictionary поэтому его необходимо создать, а после завершения операции уничтожить. Если объект не уничтожить, то переменные созданные в первом отчете будут доступны и в последующих.

```vb
dim dic
Set dic = CreateObject("Scripting.Dictionary")
```
Альтернативный вариант создания окружения это через функцию `BuildParam`. Первым параметром необходимо указать переменную с контекстом или Nothing если нужно создать новый контекст, Дальше следует набор пар `Имя_параметра, Значение`. Количество не ограниченное.

```vb
dim dic
set dic = BuildParam(Nothing, "ID", 1, "Date", date() - 1)
```

Для создания критерия фильтра используйте функцию `GetFilter`. 

```vb
Function GetFilter(pParamName As String, pOperation As tOperationType, ParamArray pdata())
```

`pParamName` - Имя параметра. Префиксы параметров для `getFilter` жестко определяют, с какими типами данных работать: `s` – строки, `n` – число, `d` – дата. От них будет зависеть, как будет отформатирован запрос. `pOperation` - применяемая операция, перечень определен в перечислении `tOperationType`.

```vb
Public Enum tOperationType
  opEQ    = 1 ' равно
  opNEQ   = 2 ' не равно
  opGR    = 4 ' больше
  opLS    = 8 ' меньше
  opNLS   = 16 ' не меньше
  opNGR   = 32 ' не больше
  opIN    = 128 ' в списке
  opNIN   = 256 ' не в списке
  opcont  = 512 ' содержит
  opSTART = 1024 ' начинается
  opBTW   = 2048 ' между
  opBTWWL = 6144 ' между без левого
  opBTWWR = 10240 ' между без правого
  opBTWWB = 14336 ' между без обоих
  opNCont = 32768 ' не содержит
End Enum
```

 Третьим и последующим параметром идут значения или 0 если критерий не применяется. Для многих операций должно быть только одно значение, для операций типа `opBTW`, `opBTWWL`, `opBTWWR`, `opBTWWB`  - два значения, для операций типа `opIN`, `opNIN` может быть много значений. Множество значений можно передавать массивом. Критерии фильтра можно перемежать с обычными параметрами.

```vb
dim dic
'Рассмотрим на примере {scan("a" for "select * from MyTable where true %nFilter; stdf:id%%sFilter; stdf:sName%"}, буду выводить только значение после where
set dic = BuildParam(Nothing, GetFilter("nFilter", opEQ, 1)) ' true and id = 1
... GetFilter("nFilter", opGR, 1) ' true and id > 1
... GetFilter("nFilter", opBTW, 1, 10) ' true and id between 1 and 10
... GetFilter("nFilter", opIn, 1, 2, 3) ' true and id in (1,2,3)
... GetFilter("nFilter", opNIn, array(1, 2, 3)) ' true and not id in (1,2,3)
... GetFilter("sFilter", opCont, "abc") ' true and sName like '%abc%'
... GetFilter("sFilter", opNCont, "abc"),  GetFilter("nFilter", opGR, 10) ' true and id > 1 and not sName like '%abc%'
```

Запуск формирования отчета

```vb
  PrintReport 1, dic 'Запускает отчет с кодом 1
  Set dic = Nothing
...
  PrintReport "d:\RTFReport\Template.rtf", dic, "d:\Complete\Report.rtf"  'Запускает отчет из шаблона на диске, результат сохраняется так же на диске
  Set dic = Nothing
...
  PrintReport "Template", dic 'Запускает отчет с именем Template
  Set dic = Nothing
```
